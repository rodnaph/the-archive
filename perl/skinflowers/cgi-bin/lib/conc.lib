###############################################################################################
###############################################################################################
##
##  conc.lib
##
###############################################################################################
###############################################################################################

use strict;

use Fcntl qw( :flock );

###############################################################################################
##
##  get_defualt_lock_file()
##
###############################################################################################

sub get_default_lock_file {

  return 'data/default.lock';

}

###############################################################################################
##
##  lock_file( fh )
##
###############################################################################################

sub lock_file {

  my ( $fh ) = @_;

  my $count = 0;
  my $delay = 1;
  my $max = 15;

  until ( flock( $fh, LOCK_EX ) | LOCK_NB ) {
    exit() if $count >= $max;
    sleep $delay;
    $count += $delay;
  }

}

###############################################################################################
##
##  unlock_file( fh )
##
###############################################################################################

sub unlock_file {

  my ( $fh ) = @_;

  flock( $fh, LOCK_UN );

}

###############################################################################################

1;

###############################################################################################
###############################################################################################